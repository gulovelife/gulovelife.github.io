<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gulovelife.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="glovelife">
<meta property="og:url" content="http://gulovelife.github.io/page/2/index.html">
<meta property="og:site_name" content="glovelife">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="gu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gulovelife.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>glovelife</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">glovelife</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/vue%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/vue%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">vue函数式组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:32:13" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1655850">https://cloud.tencent.com/developer/article/1655850</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E4%BA%8C%E5%88%86%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E4%BA%8C%E5%88%86%E6%B3%95/" class="post-title-link" itemprop="url">二分法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:26:40" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>先引用一个别人的笑话<br>有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。<br>从此，图书馆丢了 N - 1 本书。  </p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>上面的笑话简单讲了二分法的基本用法<br>在有序的数组中，查找一个特定的数，可以用到二分法，简单来说就是，取中间值，然后比较，然后再重新划分区域，然后再取中间值，然后再比较<br>但是这个简单的算法，细节非常重要，查找区间是否完整，查找区间如何调整，最终怎么取值，都是细节<br>二分法总得来说有三种应用场景，一是查找值，二是查左边界，三是查右边界。下面会一一讲解。  </p>
<h2 id="查找值"><a href="#查找值" class="headerlink" title="查找值"></a>查找值</h2><p>这是最简单的，下面一段代码基本可以套用到所有的地方</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (target === nums[middle]) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>left &lt;= right</code>是因为我们的查找区间是个闭区间，即从<code>0</code>到<code>length - 1</code>的这个区间，那么终止的条件就是<code>left &gt; right</code><br>这里有个比较坑的点，就是取middle的时候，需要用到<code>Math.floor()</code>来取整，不然<code>nums[middle]</code>和<code>target</code>比较没有结果，既不大于也不小于也不等于，然后就无法改变left和right的值，就在while里出不来了<br>由于是闭区间呢，所以每次区间调整的时候，为了不重复查找，右区间减一，左区间加一<br>return的值呢，如果有<code>target === nums[middle]</code>就返回middle，没有的话就返回-1。这是一个很基本的操作  </p>
<h2 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h2><p>左区间和上面的基本类似，改几行代码就ok了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (target === nums[middle]) &#123;</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left &gt; nums.<span class="property">length</span> || target !== nums[left])</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>修改的部分有两点。<br>一是当<code>target === nums[middle]</code>的时候，不是返回middle，而是收缩边界，由于是查找左边界，所以要将右边界收缩，排除右边的可能重复的部分，从而查找到左边界<br>为什么最总取的是left的值而不是right的值呢，因为终止条件是<code>right = left - 1</code>，而终止的前一个场景是<code>left = right = middle</code>，所以left会是最终的值。<br>但是也是要考虑到返回-1的情况的，若left下标所在的值不是我们想要的，那么就说明没有这值，返回-1。还有一种情况，如果target比所有的值都大，那么最终的情况left会大于数组的长度，因为right就是数组的长度，那么<code>nums[left]</code>就没有值，也需要返回-1  </p>
<h2 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h2><p>和左边界类似，收缩边界的方向换了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (target === nums[middle]) &#123;</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right &lt; <span class="number">0</span> || target !== nums[right])</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<p>这次是收缩左边界，然后判定返回值的方式，是如果right下标的值不对，那就返回-1，如果right小于0，就是说嘛target的值小于所有的数组中的值，说明没有目标值，返回-1 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需要注意的点就是三个</p>
<ol>
<li>当前值和目标值相等的时候怎么处理</li>
<li>返回值怎么处理</li>
<li>搜索区间，取闭区间，也可以取左开右闭，但是个人觉得不太清晰</li>
</ol>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p>LeetCode<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a><br>不完美题解：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">leftBound</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">const</span> middle = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (target === nums[middle]) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; nums.<span class="property">length</span> || nums[left] !== target) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">rightBound</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">const</span> middle = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (target === nums[middle]) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] !== target) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="title function_">leftBound</span>(), <span class="title function_">rightBound</span>()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E5%B9%B6%E6%9F%A5%E9%9B%86&Union-Find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E5%B9%B6%E6%9F%A5%E9%9B%86&Union-Find/" class="post-title-link" itemprop="url">并查集&Union-Find</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:24:25" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么叫并查集"><a href="#什么叫并查集" class="headerlink" title="什么叫并查集"></a>什么叫并查集</h2><p>并查集，又叫Union-Find算法。主要是为了解决图中的「动态连通性问题」。下面要解释一下什么叫动态联通性。  </p>
<h2 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h2><p>动态连通性就是要判断图里面的各个点的连通与否和相关的问题。主要实现的功能如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count <span class="comment">// 图中有多少连通分量</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">union</span>(<span class="params">q, p</span>)&#123;&#125; <span class="comment">// 将两个节点连接在一起</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isConnected</span>(<span class="params">q, p</span>) &#123;&#125; <span class="comment">// 判断两个点是否连通</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">q</span>) &#123;&#125; <span class="comment">// 查找节点的父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到了很多次连通，那么连通是个什么概念呢。连通是指两个节点互联。连通有如下特性。</p>
<ol>
<li>自反性：p跟p是连通的</li>
<li>对称性：p跟q连通，q跟p也连通</li>
<li>传递性：p跟r连通，p跟q连通，那么q跟r也连通<br>连通分量是什么意思呢。如果十个节点互不连通，那么这个图里的连通分量就是10。如果十个节点都相互连通，那么这个图里的连通分量就是1。</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>节点相互连通，其实也可以想象成一个树。那么我们要怎么描述这个树呢，我们可以用数组来实现这个树。<br>假设有十个节点，那么我们定义一个长为10的数组，数组的每个位置代表了一个节点，而位置上的值，代表了这个节点的父节点。如果节点就是父节点或者是一个单独的节点，那么该节点位置上的值是自己。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  parent = []</span><br><span class="line">  <span class="title function_">constructor</span> (n) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = n</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把两个节点连通，那么就是把两个节点的根节点连在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">union</span>(<span class="params">q, p</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rootQ = <span class="title function_">find</span>(q)</span><br><span class="line">  <span class="keyword">const</span> rootP = <span class="title function_">find</span>(p)</span><br><span class="line">  <span class="keyword">if</span> (rootQ === rootP) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span>[q] = p</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的就是连接两个节点的实现。首先要找到两个节点的根节点，如果两个节点的根节点是相同的，说明这两个节点就是连接的。父子关系只是定义了这两个节点的连接关系，并没有其他含义。如果这两个节点的根节点不相同，则让任意一个根节点作为另一个根节点的父节点，那么这两个节点就算建立了连接关系。<br>那么，上面的实现中有一个功能我们还没有解释，那就是怎么查找根节点，就是这个find函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">q</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(parent[q] !== q) &#123;</span><br><span class="line">    q = parent[q]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要顺着树，顺着父子关系一级一级网上找，如果发现当前节点的父节点就是自己，那么我们就算找到头了，这个节点就是根节点。<br>还有一个功能要实现，那就是判断这两个节点是否连通。很简单，就是判断根节点是否相同就好了。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isConnected</span>(<span class="params">q, p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">find</span>(q) === <span class="title function_">find</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，并查集的实现就基本上差不多了，但是还有一些优化的内容，这个等以后再补充。接下来来做个题吧。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a><br>一看标题就知道这个题非常适合用并查集来做。题目如下：</p>
<blockquote>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。  </p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] &#x3D; 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。  </p>
</blockquote>
<p>看了题解，再看看上面的对并查集的解释。这不就是妥妥的用并查集的题么。套路直接下来就能解决。根据出入的矩阵，将所有学生能连接的连接在一起，然后判断连通分量的值，连通分量就是朋友圈的数目。废话不多说，直接上代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">M</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findCircleNum = <span class="keyword">function</span> (<span class="params">M</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = M.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> parent = []</span><br><span class="line">    <span class="keyword">const</span> size = <span class="keyword">new</span> <span class="title class_">Array</span>(length).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) parent[i] = i</span><br><span class="line">    <span class="keyword">let</span> count = length</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">union</span>(<span class="params">q, p</span>) &#123;</span><br><span class="line">        q = <span class="title function_">find</span>(q)</span><br><span class="line">        p = <span class="title function_">find</span>(p)</span><br><span class="line">        <span class="keyword">if</span> (q == p) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (size[q] &gt; size[p]) &#123;</span><br><span class="line">            parent[p] = q</span><br><span class="line">            size[q] += size[p]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[q] = p</span><br><span class="line">            size[p] = q</span><br><span class="line">        &#125;</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">q</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[q] !== q) &#123;</span><br><span class="line">            parent[q] = parent[parent[q]]</span><br><span class="line">            q = parent[q]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] === <span class="number">1</span>) <span class="title function_">union</span>(i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这只是并查集的最基本的应用，接下来会补充其他的更加深入的内容。  </p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-xiang-jie">https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-xiang-jie</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" class="post-title-link" itemprop="url">最长回文子串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:29:16" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是回文子串"><a href="#什么是回文子串" class="headerlink" title="什么是回文子串"></a>什么是回文子串</h3><p>回文字符串就是正着读和反着读是一样的字符串。  </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给一个字符串，找出字符串中的最长的回文子串。<br>这个问题有很多种解法。比如暴力解法，动态规划，中心扩散，Manacher算法。</p>
<h3 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h3><p>回文子串的判定方式，最简单的就是从中间开始，向两边扩散，然后对比扩散的时候，扩散的字符是否相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">left, right, str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.<span class="property">length</span> &amp;&amp; str[left] === str[right]) &#123;</span><br><span class="line">    left--</span><br><span class="line">    right++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">substring</span>(left + <span class="number">1</span>, right) <span class="comment">// 这里要返回的字符串不是left和right所在位置的字符串，而是去除所在位置的字符之后的字符串，因为这两个位置的字符不符合要求。这点需要注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用for循环遍历字符串，让每个位置的字符都做一次中心字符，找出最大的子字符串，就ok了。<br>这里有一点要注意，回文字符串有两种，一种是奇数长度的aba，一种是偶数长度的abba，那么在扩散的时候，要扩散两种方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> len1 = <span class="title function_">isPalindrome</span>(i, i, s)</span><br><span class="line">  <span class="keyword">let</span> len2 = <span class="title function_">isPalindrome</span>(i, i + <span class="number">1</span>, s)</span><br><span class="line">  result = len1.<span class="property">length</span> &gt; result.<span class="property">length</span> ? len1 : result</span><br><span class="line">  result = len2.<span class="property">length</span> &gt; result.<span class="property">length</span> ? len2 : result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种是以i为中心的，第二种是以i和i+1中间的位置为中心的，这样就覆盖了所有位置。<br>最终代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="comment">// 中心拓展法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">left, right, str</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.<span class="property">length</span> &amp;&amp; str[left] === str[right]) &#123;</span><br><span class="line">      left--</span><br><span class="line">      right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">substring</span>(left + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> len1 = <span class="title function_">isPalindrome</span>(i, i, s)</span><br><span class="line">    <span class="keyword">let</span> len2 = <span class="title function_">isPalindrome</span>(i, i + <span class="number">1</span>, s)</span><br><span class="line">    result = len1.<span class="property">length</span> &gt; result.<span class="property">length</span> ? len1 : result</span><br><span class="line">    result = len2.<span class="property">length</span> &gt; result.<span class="property">length</span> ? len2 : result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h3><p>暴力匹配的逻辑很简单，遍历所有长度大于1的子串，然后判断是否是回文。这个简单暴力，但是时间复杂度很高。不过我们可以对这个方法进行简单的剪枝，就是只针对比当前得到的最大回文子串长的子串进行验证。如何验证这个子串是回文呢，用下面的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">left, right, str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[left] !== str[right]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟之前的验证方式是差不多的。下面是完整的代码。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">left, right, str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[left] !== str[right]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>,</span><br><span class="line">  end = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> len = s.<span class="property">length</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &gt; result &amp;&amp; <span class="title function_">isPalindrome</span>(i, j, s)) &#123;</span><br><span class="line">      result = j - i</span><br><span class="line">      end = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.<span class="title function_">substr</span>(end, result + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>待补充</p>
<h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>待补充</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E6%9F%AF%E9%87%8C%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E6%9F%AF%E9%87%8C%E5%8C%96/" class="post-title-link" itemprop="url">柯里化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:28:55" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h1><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。–维基百科<br>用人话讲，柯里化就是将一个有很多入参的函数，变成一个可以一个一个传入入参的函数，分步调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"><span class="keyword">const</span> sum = <span class="title function_">curry</span>(add)</span><br><span class="line"><span class="keyword">const</span> add1 = <span class="title function_">add</span>(<span class="number">1</span>) <span class="comment">// 返回一个函数</span></span><br><span class="line"><span class="title function_">add1</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">add1</span>(<span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>既然要将很多入参变成一个一个传入的，那就需要柯里化的函数里记录之前传入的参数。在返回函数之中记录参数，可以用到闭包。<br>所以我们的实现方式就是，用闭包将需要柯里化的函数的参数保存起来，当达到我们想要的个数的时候，再执行函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span> - arg.<span class="property">length</span> <span class="comment">// 判断剩余的参数个数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123; <span class="comment">// 获取当前传入的参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; length) &#123; <span class="comment">// 进行对比</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">curry</span>(fn, ...arg, ...args) <span class="comment">// 参数不够，则继续执行柯里化，将传入的参数带上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [...arg, ...args]) <span class="comment">// 参数够了，则执行函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是将传入的入参保存了起来，保存到arg当中，然后每次检查arg的长度加上新传入的参数的长度，跟fn.length的长度是否一样，或者超过。如果小于原函数的参数大小，则递归返回一个curry的函数，否则执行fn。这个的好处是，在初始化curry函数的时候，就可以直接传入参数。<br>看一下另一个实现方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考自 segmentfault 的@大笑平 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">currying</span> = fn =&gt;</span><br><span class="line">  judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    args.<span class="property">length</span> &gt;= fn.<span class="property">length</span> ?</span><br><span class="line">    <span class="title function_">fn</span>(...args) :</span><br><span class="line">    <span class="function">(<span class="params">...arg</span>) =&gt;</span> <span class="title function_">judge</span>(...args, ...arg)</span><br></pre></td></tr></table></figure>
<p>极简的实现方式，极度舒适。这个第一次初始化没办法传入参数。通过arg和args交替保存参数。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...args</span>) =&gt; args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          args.<span class="title function_">push</span>(...rest);</span><br><span class="line">        	<span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 未真正求值</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">4</span>); 		 <span class="comment">// 未真正求值</span></span><br><span class="line"><span class="title function_">sum</span>(); 			 <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>
<p>bind也可以实现延迟计算，就是MDN上面的bind的偏函数示例</p>
<h2 id="动态创建函数"><a href="#动态创建函数" class="headerlink" title="动态创建函数"></a>动态创建函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addEvent = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">elem, type, fn, capture</span>) =&gt;</span> &#123;</span><br><span class="line">            elem.<span class="title function_">addEventListener</span>(type, <span class="function">(<span class="params">e</span>) =&gt;</span> fn.<span class="title function_">call</span>(elem, e), capture);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">elem, type, fn, capture</span>) =&gt;</span> &#123;</span><br><span class="line">            elem.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, <span class="function">(<span class="params">e</span>) =&gt;</span> fn.<span class="title function_">call</span>(elem, e);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>动态返回一个新的函数，不用每次都要if else判断</p>
<h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们就想让一个数加一，那么用上面的函数，就得每次都加上参数1，但是如果用柯里化，就像下面这样</span></span><br><span class="line"><span class="keyword">let</span> addOne = <span class="title function_">curry</span>(add, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">addOne</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">addOne</span>(<span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 这样就能不必每次都写这个参数1了</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E8%B7%9F%E7%9D%80lodash%E5%AD%A6%E8%8A%82%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E8%B7%9F%E7%9D%80lodash%E5%AD%A6%E8%8A%82%E6%B5%81/" class="post-title-link" itemprop="url">跟着lodash学节流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:27:21" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h2><p>节流的概念是什么呢。<br>节流就是在高频触发一个事件的时候，单位事件内只触发一次事件，目的是为了稀释事件执行频率  </p>
<p><strong>看了lodash的节流，发现节流其实就是在防抖的基础上加一个最大执行的时间，就是maxWait。</strong></p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>节流有其他的写法，之后再补充  </p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/26">https://github.com/mqyqingfeng/Blog/issues/26</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/%E8%B7%9F%E7%9D%80lodash%E5%AD%A6%E9%98%B2%E6%8A%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/%E8%B7%9F%E7%9D%80lodash%E5%AD%A6%E9%98%B2%E6%8A%96/" class="post-title-link" itemprop="url">跟着lodash学防抖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-15 16:56:26 / Modified: 17:27:05" itemprop="dateCreated datePublished" datetime="2023-10-15T16:56:26+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h2><p>防抖是什么？<br>防抖是指一个事件在频繁触发的时候，不允许该事件执行，而是在一定间隔之后才执行，如果该事件在这个间隔内又被触发了，那么重新计时<br>根据这个描述，我们可以简单的写出一个debounce函数  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中需要保存this和arguments的值，来修复this指向和event对象的问题</p>
<h2 id="根据lodash的源码分步实现"><a href="#根据lodash的源码分步实现" class="headerlink" title="根据lodash的源码分步实现"></a>根据lodash的源码分步实现</h2><p>由上面的防抖的基本思路，我们来一步一步实现lodash的防抖</p>
<h3 id="第一步-基础"><a href="#第一步-基础" class="headerlink" title="第一步-基础"></a>第一步-基础</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId, lastArgs, lastThis</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发函数 func</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    func.<span class="title function_">apply</span>(lastThis, lastArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器到期后的执行函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">timeExpired</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">invokeFunction</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(timeExpired, wait)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要返回的debounce函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">    lastArgs = arg</span><br><span class="line">    lastThis = <span class="variable language_">this</span></span><br><span class="line">    timerId = <span class="title function_">startTimer</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最基础的部分，我们根据上面第一部分的debounce原理，将代码分成了四个部分，方便之后的拓展  </p>
<h4 id="invokeFunction"><a href="#invokeFunction" class="headerlink" title="invokeFunction"></a>invokeFunction</h4><ul>
<li>这个函数的目的是触发传入的func，并在触发之前做一些操作</li>
</ul>
<h4 id="timeExpired"><a href="#timeExpired" class="headerlink" title="timeExpired"></a>timeExpired</h4><ul>
<li>这个函数是在定时器执行到期之后触发的函数</li>
</ul>
<h4 id="startTimer"><a href="#startTimer" class="headerlink" title="startTimer"></a>startTimer</h4><ul>
<li>顾名思义，这个是开始，或者更新定时器的函数</li>
</ul>
<h4 id="debounced"><a href="#debounced" class="headerlink" title="debounced"></a>debounced</h4><ul>
<li>一个包装了所有其他函数的基础函数，这个函数会被返回</li>
</ul>
<h3 id="第二步-时间的优化"><a href="#第二步-时间的优化" class="headerlink" title="第二步-时间的优化"></a>第二步-时间的优化</h3><p>上面的第一步已经基本实现我们的需求了，下面进行一些优化。<br>每次我们重置定时器的时候，用的都是wait，但是有可能出现时间的偏差。比如最后一次触发的时候是第10秒，我们定义的等待时间是5秒，但是由于一些原因呢，重置定时器时已经到第11秒了，那么只能在第16秒才能触发函数。这跟我们的预期是不一样的。那么我们就需要对重置定时器时的等待时间进行优化。  </p>
<ul>
<li>首先我们需要定义一个变量来缓存上次触发debounce时的时间</li>
<li>然后我们取当前的时间和这个时间进行对比，然后再和等待时间wait对比</li>
<li>这次我们修改一下timerId定义和处理的方式</li>
<li>加入canInvoke函数，来判断应该重置timerId还是触发函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId,</span><br><span class="line">    lastArgs,</span><br><span class="line">    lastThis,</span><br><span class="line">    lastCallTime</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出发函数 func</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span></span><br><span class="line">    func.<span class="title function_">apply</span>(lastThis, lastArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器到期后的执行函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">timeExpired</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">canInvoke</span>(time)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">invokeFunction</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(<span class="title function_">remainingWait</span>(time))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算真正的应该设置延迟的时间</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">remainingWait</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeWaiting</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否能够触发函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">canInvoke</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> || <span class="comment">// 第一次触发</span></span><br><span class="line">      timeSinceLastCall &gt;= wait || <span class="comment">// 时间到了</span></span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> <span class="comment">// 系统时间被改了</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(timeExpired, time)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要返回的debounce函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"></span><br><span class="line">    lastArgs = arg</span><br><span class="line">    lastThis = <span class="variable language_">this</span></span><br><span class="line">    lastCallTime = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步-加入trailing参数和trailingEdge函数"><a href="#第三步-加入trailing参数和trailingEdge函数" class="headerlink" title="第三步-加入trailing参数和trailingEdge函数"></a>第三步-加入trailing参数和trailingEdge函数</h3><p>防抖有两种触发方式，一种是前置触发，一种是后置触发。后置触发就是正常的在高频操作之后几秒后进行触发。前置触发就是在我们第一次触发这个操作的时间就触发一次这个函数。我们可以加入两个参数来控制前置还是后置。前置为leading，后置为trailing。  </p>
<ul>
<li>首先我们要定义一个trailing变量，并初始化为true，因为默认的都是后置。</li>
<li>参数中加一个options，里面定义trailing，然后我们需要对其进行校验</li>
<li>添加一个trailingEdge函数</li>
<li>更改调用方式，不调用原来的invokeFunction，而是调用trailingEdge函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId,</span><br><span class="line">    lastArgs,</span><br><span class="line">    lastThis,</span><br><span class="line">    lastCallTime</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">isObject</span>(options)) &#123;</span><br><span class="line">    trailing = <span class="string">&#x27;trailing&#x27;</span> <span class="keyword">in</span> options ? !!options.<span class="property">trailing</span> : trailing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是object</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出发函数 func</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    func.<span class="title function_">apply</span>(lastThis, lastArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器到期后的执行函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">timeExpired</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">canInvoke</span>(time)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">trailingEdge</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(<span class="title function_">remainingWait</span>(time))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算真正的应该设置延迟的时间</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">remainingWait</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeWaiting</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否能够触发函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">canInvoke</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> || <span class="comment">// 第一次触发</span></span><br><span class="line">      timeSinceLastCall &gt;= wait || <span class="comment">// 时间到了</span></span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> <span class="comment">// 系统时间被改了</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(timeExpired, time)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后置触发的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">trailingEdge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 这里引用其他人的解释，目前我不是很清楚</span></span><br><span class="line">    <span class="comment">// 只有当事件至少发生过一次且配置了末端触发才调用真正的事件处理事件，</span></span><br><span class="line">    <span class="comment">// 意思是如果程序设置了末端触发，且没有设置最大等待时间</span></span><br><span class="line">    <span class="comment">// 但是时间自始至终只触发了一次，则真正的事件处理程序永远不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">      <span class="title function_">invokeFunction</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    lastThis = lastArgs = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要返回的debounce函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"></span><br><span class="line">    lastArgs = arg</span><br><span class="line">    lastThis = <span class="variable language_">this</span></span><br><span class="line">    lastCallTime = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步-加入leading参数和leadingEdge函数"><a href="#第四步-加入leading参数和leadingEdge函数" class="headerlink" title="第四步-加入leading参数和leadingEdge函数"></a>第四步-加入leading参数和leadingEdge函数</h3><p>leading是指前置触发，也就是说，一开始触发debounce就要触发</p>
<ul>
<li>首先定义一个leading变量，初始化为false</li>
<li>在options里面加入leading，并赋值</li>
<li>添加leadingEdge函数，并在最开始调用，leadingEdge函数中要判断是否要立即调用函数，并初始化定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId,</span><br><span class="line">    lastArgs,</span><br><span class="line">    lastThis,</span><br><span class="line">    lastCallTime</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span>,</span><br><span class="line">    leading = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">isObject</span>(options)) &#123;</span><br><span class="line">    leading = !!options.<span class="property">leading</span></span><br><span class="line">    trailing = <span class="string">&#x27;trailing&#x27;</span> <span class="keyword">in</span> options ? !!options.<span class="property">trailing</span> : trailing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是object</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出发函数 func</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    func.<span class="title function_">apply</span>(lastThis, lastArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器到期后的执行函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">timeExpired</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">canInvoke</span>(time)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">trailingEdge</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(<span class="title function_">remainingWait</span>(time))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算真正的应该设置延迟的时间</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">remainingWait</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeWaiting</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否能够触发函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">canInvoke</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> || <span class="comment">// 第一次触发</span></span><br><span class="line">      timeSinceLastCall &gt;= wait || <span class="comment">// 时间到了</span></span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> <span class="comment">// 系统时间被改了</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(timeExpired, time)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后置触发的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">trailingEdge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 这里引用其他人的解释，目前我不是很清楚</span></span><br><span class="line">    <span class="comment">// 只有当事件至少发生过一次且配置了末端触发才调用真正的事件处理事件，</span></span><br><span class="line">    <span class="comment">// 意思是如果程序设置了末端触发，且没有设置最大等待时间</span></span><br><span class="line">    <span class="comment">// 但是时间自始至终只触发了一次，则真正的事件处理程序永远不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">      <span class="title function_">invokeFunction</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    lastThis = lastArgs = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前置触发的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">leadingEdge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    leading &amp;&amp; <span class="title function_">invokeFunction</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要返回的debounce函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">const</span> isInvoking = <span class="title function_">canInvoke</span>(time)</span><br><span class="line"></span><br><span class="line">    lastArgs = arg</span><br><span class="line">    lastThis = <span class="variable language_">this</span></span><br><span class="line">    lastCallTime = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="title function_">leadingEdge</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负责一种情况，如果后置触发，已经触发过一次了，</span></span><br><span class="line">    <span class="comment">// 然后timerId被设置成undefined，在wait时间内触发的时候，我们需要再次初始化一次计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五步-加入maxWait"><a href="#第五步-加入maxWait" class="headerlink" title="第五步-加入maxWait"></a>第五步-加入maxWait</h3><p>maxWait的意思是，经过maxWait时间后，事件如果还没触发，则必须触发一次<br>如何实现呢，lodash是在remainingWait上面做文章，如果有这个maxWait，则会看看距离最近的一次触发的时间，和maxWait哪个长，如果到了maxWait的时间了，则触发。</p>
<ul>
<li>首先需要加入一个lastInvokeTime变量，来记录最后一次调用的时间</li>
<li>然后加入maxWait参数</li>
<li>更改remainingWait函数和canInvoke函数，兼容这种情况</li>
<li>修改debounced函数，在可以触发的时候，如果是因为maxWait的原因，重置定时器，触发函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId,</span><br><span class="line">    lastArgs,</span><br><span class="line">    lastThis,</span><br><span class="line">    lastCallTime,</span><br><span class="line">    maxWait</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span>,</span><br><span class="line">    leading = <span class="literal">false</span>,</span><br><span class="line">    maxing = <span class="literal">false</span>,</span><br><span class="line">    lastInvokeTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(options)) &#123;</span><br><span class="line">    maxing = <span class="string">&#x27;maxWait&#x27;</span> <span class="keyword">in</span> options</span><br><span class="line">    <span class="comment">// 如果延迟的时间(wait)大于最大的延迟时间(maxWait)，则取延迟时间为最大延迟时间</span></span><br><span class="line">    maxWait = maxing ? <span class="title class_">Math</span>.<span class="title function_">max</span>(+options.<span class="property">maxWait</span> || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">    leading = !!options.<span class="property">leading</span></span><br><span class="line">    trailing = <span class="string">&#x27;trailing&#x27;</span> <span class="keyword">in</span> options ? !!options.<span class="property">trailing</span> : trailing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是object</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出发函数 func</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeFunction</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = lastArgs</span><br><span class="line">    <span class="keyword">const</span> that = lastThis</span><br><span class="line">    lastInvokeTime = time</span><br><span class="line">    lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">    func.<span class="title function_">apply</span>(that, args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器到期后的执行函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">timeExpired</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">canInvoke</span>(time)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">trailingEdge</span>(time)</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(<span class="title function_">remainingWait</span>(time))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算真正的应该设置延迟的时间</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">remainingWait</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime <span class="comment">// 距离上次调用的时间</span></span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime <span class="comment">// 距离上次触发的时间</span></span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall <span class="comment">// 调整后的需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxing ? <span class="title class_">Math</span>.<span class="title function_">min</span>(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否能够触发函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">canInvoke</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> || <span class="comment">// 第一次触发</span></span><br><span class="line">      timeSinceLastCall &gt;= wait || <span class="comment">// 时间到了</span></span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> || <span class="comment">// 系统时间被改了</span></span><br><span class="line">      (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait) <span class="comment">// 有最大触发时间，而且距离上次触发的时间大于maxWait</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(timeExpired, time)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后置触发的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">trailingEdge</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 这里引用其他人的解释，目前我不是很清楚</span></span><br><span class="line">    <span class="comment">// 只有当事件至少发生过一次且配置了末端触发才调用真正的事件处理事件，</span></span><br><span class="line">    <span class="comment">// 意思是如果程序设置了末端触发，且没有设置最大等待时间</span></span><br><span class="line">    <span class="comment">// 但是时间自始至终只触发了一次，则真正的事件处理程序永远不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">      <span class="title function_">invokeFunction</span>(time)</span><br><span class="line">    &#125;</span><br><span class="line">    lastThis = lastArgs = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前置触发的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">leadingEdge</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    lastInvokeTime = time <span class="comment">// 重置最近一次触发时间</span></span><br><span class="line">    timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    leading ? <span class="title function_">invokeFunction</span>(time) : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要返回的debounce函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">const</span> isInvoking = <span class="title function_">canInvoke</span>(time)</span><br><span class="line"></span><br><span class="line">    lastArgs = arg</span><br><span class="line">    lastThis = <span class="variable language_">this</span></span><br><span class="line">    lastCallTime = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">leadingEdge</span>(lastCallTime)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">        timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">invokeFunction</span>(lastCallTime)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负责一种情况，如果后置触发，已经触发过一次了，</span></span><br><span class="line">    <span class="comment">// 然后timerId被设置成undefined，在wait时间内触发的时候，我们需要再次初始化一次计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = <span class="title function_">startTimer</span>(wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样基本上就是把lodash的防抖函数都扒的差不多了，除了一些取消和立即执行的函数，和一些其他附加的东西，这些之后再补充，不过也不是特别重要</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/22">https://github.com/mqyqingfeng/Blog/issues/22</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903990639984654#heading-5">https://juejin.im/post/6844903990639984654#heading-5</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://gulovelife.github.io/2023/10/15/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glovelife">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/15/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-15 16:53:40" itemprop="dateCreated datePublished" datetime="2023-10-15T16:53:40+08:00">2023-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">gu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
